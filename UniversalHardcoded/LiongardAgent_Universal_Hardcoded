<#
.SYNOPSIS
    Liongard Agent Installation (v2.9.2)
.DESCRIPTION
    - RMM Translation: Outputs the "English" error reason (e.g., "Security Blocked") to RMM StdOut.
    - Network Resilience: Retries failed downloads.
    - Process Hygiene: Kills stuck MSIExec processes.
#>

# --- 1. PARAMETERS ---
param(
    [string]$Url,
    [string]$AccessKey,
    [string]$AccessSecret,
    [string]$Environment
)

# --- 2. CONFIGURATION ---
$Hardcoded_Url          = ""   
$Hardcoded_AccessKey    = ""   
$Hardcoded_AccessSecret = ""   
$Hardcoded_Environment  = ""   

# =======================================================
# --- SCRIPT LOGIC ---
# =======================================================

# --- 3. Logic: Prioritize Hardcoded -> Param ---
if (-not [string]::IsNullOrWhiteSpace($Hardcoded_Url))          { $Url = $Hardcoded_Url }
if (-not [string]::IsNullOrWhiteSpace($Hardcoded_AccessKey))    { $AccessKey = $Hardcoded_AccessKey }
if (-not [string]::IsNullOrWhiteSpace($Hardcoded_AccessSecret)) { $AccessSecret = $Hardcoded_AccessSecret }
if (-not [string]::IsNullOrWhiteSpace($Hardcoded_Environment))  { $Environment = $Hardcoded_Environment }

# --- 4. Sanitization ---
if ($Url -match "https://") { $Url = $Url -replace "https://","" -replace "/","" }
if ($Url -notmatch "\.app\.liongard\.com") { $Url = "$Url.app.liongard.com"; Write-Host "Auto-corrected URL to: $Url" }

if (-not [string]::IsNullOrWhiteSpace($Environment)) {
    try {
        $normalized = $Environment -replace '\+',' '
        $decoded = [System.Uri]::UnescapeDataString($normalized)
        if ($decoded -ne $Environment) { $Environment = $decoded; Write-Host "Auto-decoded Environment: '$Environment'" }
    } catch {}
}

# --- 5. Setup & Logging ---
$Folder          = "$env:ProgramData\Liongard"
$LogFile         = "$Folder\ScriptInstall.log"
$TranscriptPath  = "$Folder\TranscriptLog.txt"

if (-not (Test-Path -Path $Folder)) { New-Item -Path $Folder -ItemType Directory -ErrorAction SilentlyContinue | Out-Null }
try { Start-Transcript -Path $TranscriptPath -Append -Force -ErrorAction Stop } 
catch { Write-Host "WARNING: Transcript failed." -ForegroundColor Yellow }

function Write-Log {
    param( [string]$Message, [string]$Type="INFO" )
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogEntry = "[$Timestamp] [$Type] $Message"
    Write-Host $LogEntry
    Add-Content -Path $LogFile -Value $LogEntry -Encoding Default -ErrorAction SilentlyContinue
}

function Exit-Smart {
    param ([int]$Code)
    Stop-Transcript -ErrorAction SilentlyContinue
    if ([Environment]::UserInteractive) {
        Write-Host "`n---------------------------------------------------"
        if ($Code -ne 0) { Write-Host "SCRIPT FAILED (Exit Code $Code)" -ForegroundColor Red }
        else { Write-Host "SCRIPT FINISHED SUCCESSFULLY" -ForegroundColor Green }
        Write-Host "---------------------------------------------------"
        Read-Host "Press Enter to close..."
    }
    Exit $Code
}

Write-Log "--- Starting Liongard Agent Installation (v2.9.2) ---"

# --- 6. Validation ---
if ([string]::IsNullOrWhiteSpace($Url) -or [string]::IsNullOrWhiteSpace($AccessKey) -or [string]::IsNullOrWhiteSpace($AccessSecret) -or $Url -match "YOUR_") {
    Write-Output "FAILURE_REASON: Missing Credentials. Please check script parameters."
    Write-Log "FATAL ERROR: Credentials missing." "ERROR"
    Exit-Smart 1
}

$MsiPath         = "$env:TEMP\LiongardAgent-lts.msi" 
$DownloadUri     = "https://agents.static.liongard.com/LiongardAgent-lts.msi"
$MinMsiSize      = 10485760 
$MinFreeSpaceMB  = 200
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12 -bor [System.Net.SecurityProtocolType]::Tls13

# --- 7. Pre-Flight Hygiene ---
Write-Log "Performing Pre-Flight Hygiene..."
$StuckMsi = Get-Process -Name "msiexec" -ErrorAction SilentlyContinue
if ($StuckMsi) {
    Write-Log "Killing stuck msiexec processes..." "WARN"
    Stop-Process -Name "msiexec" -Force -ErrorAction SilentlyContinue
    Start-Sleep -Seconds 3
}

if (Get-Service | Where-Object { $_.Name -like "*Liongard*" -or $_.DisplayName -like "*Liongard*" }) {
    Write-Output "FAILURE_REASON: Liongard Agent is already installed."
    Write-Log "Agent service already present. Aborting." "WARN"
    Exit-Smart 0
}

try {
    $Disk = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'" | Select-Object FreeSpace
    if (([math]::Round($Disk.FreeSpace / 1MB)) -lt $MinFreeSpaceMB) { throw "Insufficient disk space (Need 200MB+)." }
}
catch { 
    Write-Output "FAILURE_REASON: Pre-Check Failed - $_"
    Write-Log "Pre-check failed: $_" "ERROR"
    Exit-Smart 1 
}

# --- 8. Download with Retry Logic ---
Write-Log "Downloading MSI..."
$DownloadSuccess = $false; $Attempts = 0
do {
    $Attempts++
    try {
        Write-Log "Attempt $Attempts of 3..."
        Invoke-WebRequest -Uri $DownloadUri -OutFile $MsiPath -UseBasicParsing -ErrorAction Stop
        if ((Get-Item $MsiPath).Length -ge $MinMsiSize) { $DownloadSuccess = $true; Write-Log "Download Complete." } 
        else { throw "File too small (Corrupt)." }
    }
    catch { Write-Log "Download failed: $_" "WARN"; Start-Sleep -Seconds 5 }
} until ($DownloadSuccess -or $Attempts -ge 3)

if (-not $DownloadSuccess) {
    Write-Output "FAILURE_REASON: Failed to download MSI after 3 attempts."
    Write-Log "FATAL ERROR: Download failed." "ERROR"
    Exit-Smart 1
}

# --- 9. Install Logic ---
Write-Log "Installing Liongard Agent..."
$EnvArg = if (-not [string]::IsNullOrWhiteSpace($Environment)) { "LIONGARDENVIRONMENT=`"$Environment`"" } else { "" }
$InstallLog = "$Folder\AgentInstall.log"
$InstallArgs = "/i `"$MsiPath`" LIONGARDURL=$Url LIONGARDACCESSKEY=$AccessKey LIONGARDACCESSSECRET=$AccessSecret $EnvArg LIONGARDAGENTNAME=`"$env:computername`" /qn /norestart /L*V `"$InstallLog`""

try {
    $Process = Start-Process -FilePath "msiexec.exe" -ArgumentList $InstallArgs -Wait -PassThru -NoNewWindow
    $MsiExitCode = $Process.ExitCode
    
    if ($MsiExitCode -ne 0 -and $MsiExitCode -ne 3010) { 
        # Default Reason
        $FailureReason = "Unknown MSI Error (Code $MsiExitCode)"
        Start-Sleep -Seconds 2
        
        if (Test-Path $InstallLog) {
            $LogContent = Get-Content $InstallLog
            
            # --- TRANSLATION ENGINE ---
            if ($LogContent | Select-String "Error code 0x80070005") {
                $FailureReason = "SECURITY BLOCK (0x80070005): ThreatLocker/S1 blocked temp file execution. Whitelist 'Liongard Inc'."
            }
            elseif ($LogContent | Select-String "Error 1920") {
                $FailureReason = "SERVICE FAILURE (1920): Agent installed but service failed to start. Check AV Quarantine."
            }
            elseif ($MsiExitCode -eq 1638) {
                $FailureReason = "VERSION CONFLICT (1638): A newer version is already installed."
            }
            elseif ($MsiExitCode -eq 1618) {
                $FailureReason = "INSTALLER BUSY (1618): Another installation is running. Wait 15 mins."
            }
            elseif ($MsiExitCode -eq 1612) {
                $FailureReason = "REGISTRY CORRUPTION (1612): Deep Clean required."
            }
            elseif ($Match = ($LogContent | Select-String "INVALIDMSG = (.*)" | Select-Object -Last 1)) {
                 $FailureReason = "INPUT ERROR: $($Match.Matches.Groups[1].Value)"
            }
        }
        # Throw the translated string to the catch block
        throw $FailureReason
    }
}
catch { 
    # CAPTURE THE TRANSLATION
    $TranslatedError = $_.Exception.Message

    # 1. Write to Script Log
    Write-Log "$TranslatedError" "ERROR"

    # 2. OUTPUT TO RMM DASHBOARD (This is what you see in the ticket)
    Write-Output "FAILURE_REASON: $TranslatedError"

    # 3. Exit with 1 (General Error) so RMM marks it as failed
    Exit-Smart 1 
}

# --- 10. Verification ---
Write-Log "Verifying Service Startup..."
$Retry = 0; $Started = $false
do {
    Start-Sleep -Seconds 5
    $Service = Get-Service | Where-Object { $_.Name -like "*Liongard*" -or $_.DisplayName -like "*Liongard*" } | Select-Object -First 1
    if ($Service -and $Service.Status -eq "Running") { $Started = $true }
    $Retry++
} until ($Started -or $Retry -ge 24)

if ($Started) { 
    Write-Log "SUCCESS: Service is Running." 
    Remove-Item $MsiPath -Force -ErrorAction SilentlyContinue
    Exit-Smart 0
} else { 
    Write-Output "FAILURE_REASON: Installation appeared successful, but Service is NOT running."
    Write-Log "WARNING: Service installed but not running." "WARN"
    Exit-Smart 1
}
