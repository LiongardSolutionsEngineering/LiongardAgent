<#
.SYNOPSIS
    Liongard Agent RE-INSTALLATION (v2.9.1)
.DESCRIPTION
    - Actions: Downloads fresh MSI -> Removes Old Agent -> Deep Cleans Registry -> Installs New Agent.
    - Network Resilience: Retries failed downloads (fixes SSL/TLS dropped connections).
    - Process Hygiene: Kills stuck MSIExec processes before starting.
    - Error Engine: Translates 1603, 1612, 1618, 1638, 1920, and Access Denied into English.
#>

# --- 1. PARAMETERS (MUST BE FIRST) ---
# These accept values passed from your RMM (e.g. -Url "xyz.app.liongard.com")
param(
    [string]$Url,
    [string]$AccessKey,
    [string]$AccessSecret,
    [string]$Environment
)

# --- 2. CONFIGURATION (HARDCODE OVERRIDES) ---
# If you enter values here, they will OVERRIDE the parameters above.
$Hardcoded_Url          = ""   # e.g. "instance.app.liongard.com"
$Hardcoded_AccessKey    = ""   # e.g. "BnKs..."
$Hardcoded_AccessSecret = ""   # e.g. "89s7..."
$Hardcoded_Environment  = ""   # Optional

# =======================================================
# --- SCRIPT LOGIC (DO NOT EDIT BELOW) ---
# =======================================================

# --- 3. Logic: Prioritize Hardcoded -> Param ---
if (-not [string]::IsNullOrWhiteSpace($Hardcoded_Url))          { $Url = $Hardcoded_Url }
if (-not [string]::IsNullOrWhiteSpace($Hardcoded_AccessKey))    { $AccessKey = $Hardcoded_AccessKey }
if (-not [string]::IsNullOrWhiteSpace($Hardcoded_AccessSecret)) { $AccessSecret = $Hardcoded_AccessSecret }
if (-not [string]::IsNullOrWhiteSpace($Hardcoded_Environment))  { $Environment = $Hardcoded_Environment }

# --- 4. Sanitization & Smart Decoding ---
if ($Url -match "https://") { $Url = $Url -replace "https://","" -replace "/","" }
if ($Url -notmatch "\.app\.liongard\.com") { $Url = "$Url.app.liongard.com"; Write-Host "Auto-corrected URL to: $Url" }

if (-not [string]::IsNullOrWhiteSpace($Environment)) {
    try {
        $normalized = $Environment -replace '\+',' '
        $decoded = [System.Uri]::UnescapeDataString($normalized)
        if ($decoded -ne $Environment) { 
            $Environment = $decoded
            Write-Host "Auto-decoded Environment name to: '$Environment'"
        }
    } catch {}
}

# --- 5. Setup & Logging ---
$Folder          = "$env:ProgramData\Liongard"
$LogFile         = "$Folder\ScriptReinstall.log"
$TranscriptPath  = "$Folder\TranscriptReinstall.txt"

if (-not (Test-Path -Path $Folder)) { New-Item -Path $Folder -ItemType Directory -ErrorAction SilentlyContinue | Out-Null }
try { Start-Transcript -Path $TranscriptPath -Append -Force -ErrorAction Stop } 
catch { Write-Host "WARNING: Transcript failed. Proceeding without it." -ForegroundColor Yellow }

function Write-Log {
    param( [string]$Message, [string]$Type="INFO" )
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogEntry = "[$Timestamp] [$Type] $Message"
    Write-Host $LogEntry
    Add-Content -Path $LogFile -Value $LogEntry -Encoding Default -ErrorAction SilentlyContinue
}

function Exit-Smart {
    param ([int]$Code)
    Stop-Transcript -ErrorAction SilentlyContinue
    if ([Environment]::UserInteractive) {
        Write-Host "`n---------------------------------------------------"
        if ($Code -ne 0) { Write-Host "SCRIPT FAILED (Exit Code $Code) - Check logs above." -ForegroundColor Red }
        else { Write-Host "SCRIPT FINISHED SUCCESSFULLY" -ForegroundColor Green }
        Write-Host "---------------------------------------------------"
        Read-Host "Press Enter to close this window..."
    }
    Exit $Code
}

Write-Log "--- Starting Liongard Agent RE-INSTALLATION (Omniscient v2.9.1) ---"

# --- 6. Validation ---
if ([string]::IsNullOrWhiteSpace($Url) -or [string]::IsNullOrWhiteSpace($AccessKey) -or [string]::IsNullOrWhiteSpace($AccessSecret) -or $Url -match "YOUR_") {
    Write-Log "FATAL ERROR: Credentials missing. Provide Parameters OR edit the Configuration section." "ERROR"
    Exit-Smart 1
}

$MsiPath         = "$env:TEMP\LiongardAgent-lts.msi" 
$DownloadUri     = "https://agents.static.liongard.com/LiongardAgent-lts.msi"
$MinMsiSize      = 10485760 
$MinFreeSpaceMB  = 200

# Enforce Strong Crypto (TLS 1.2 / 1.3)
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12 -bor [System.Net.SecurityProtocolType]::Tls13

# --- 7. Pre-Flight Hygiene (Process Killing) ---
Write-Log "Performing Pre-Flight Hygiene..."

# Kill stuck MSI processes (Fixes Error 1618)
$StuckMsi = Get-Process -Name "msiexec" -ErrorAction SilentlyContinue
if ($StuckMsi) {
    Write-Log "Found stuck msiexec process(es). Terminating..." "WARN"
    Stop-Process -Name "msiexec" -Force -ErrorAction SilentlyContinue
    Start-Sleep -Seconds 3
}

try {
    $Disk = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'" | Select-Object FreeSpace
    if (([math]::Round($Disk.FreeSpace / 1MB)) -lt $MinFreeSpaceMB) { throw "Insufficient disk space." }
}
catch { Write-Log "Pre-check failed: $_" "ERROR"; Exit-Smart 1 }

# --- 8. Download with Retry Logic ---
Write-Log "Downloading MSI..."
$DownloadSuccess = $false
$Attempts = 0
$MaxAttempts = 3

do {
    $Attempts++
    try {
        Write-Log "Attempt $Attempts of $MaxAttempts..."
        Invoke-WebRequest -Uri $DownloadUri -OutFile $MsiPath -UseBasicParsing -ErrorAction Stop
        if ((Get-Item $MsiPath).Length -ge $MinMsiSize) { 
            $DownloadSuccess = $true 
            Write-Log "Download Complete."
        } else { throw "File too small (Corrupt)." }
    }
    catch {
        Write-Log "Download failed ($($_)): $_" "WARN"
        Start-Sleep -Seconds 5 
    }
} until ($DownloadSuccess -or $Attempts -ge $MaxAttempts)

if (-not $DownloadSuccess) {
    Write-Log "FATAL ERROR: Failed to download MSI after $MaxAttempts attempts." "ERROR"
    Exit-Smart 1
}

# --- 9. Detection & Removal Logic (Standard) ---
Write-Log "Phase 1: Standard Removal Checks..."
$ExistingService = Get-Service | Where-Object { $_.Name -like "*Liongard*" -or $_.DisplayName -like "*Liongard*" }

if ($ExistingService) {
    Write-Log "Existing Agent Found: $($ExistingService.Name)."
    if ($ExistingService.Status -eq 'Running') {
        Stop-Service $ExistingService.Name -Force -ErrorAction SilentlyContinue
        Start-Sleep -Seconds 5
    }

    $UninstallKey = Get-ChildItem -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall, HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall -ErrorAction SilentlyContinue |
        Get-ItemProperty | Where-Object { $_.DisplayName -like "*Liongard Agent*" } | Select-Object -First 1

    if ($UninstallKey) {
        $UninstallString = $UninstallKey.UninstallString
        if ($UninstallString -match "MsiExec.exe") {
            $ProductCode = ($UninstallKey.UninstallString -replace "MsiExec.exe", "" -replace "/I", "" -replace "/X", "").Trim()
            Write-Log "Uninstalling Standard Product Code: $ProductCode"
            Start-Process "msiexec.exe" -ArgumentList "/x $ProductCode /qn /norestart" -Wait
        }
    }
}

# --- 10. Deep Clean Logic (Fix for Error 1612 & Error 3:2) ---
Write-Log "Phase 2: Deep Registry Clean (Hunting for Ghost/Corrupted Entries)..."
$AppName = "Liongard"
$DeepCleanFound = $false
# Use Registry:: provider to ensure consistency across 32/64-bit PS sessions
$HKCR_Products = "Registry::HKEY_CLASSES_ROOT\Installer\Products"
$HKLM_Rollback = "Registry::HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Installer\Rollback"

# A. Search Packed Installer Products (Error 1612)
if (Test-Path $HKCR_Products) {
    Get-ChildItem -Path $HKCR_Products -ErrorAction SilentlyContinue | ForEach-Object {
        $ProdName = (Get-ItemProperty -Path $_.PSPath -Name "ProductName" -ErrorAction SilentlyContinue).ProductName
        if ($ProdName -like "*$AppName*") {
            Write-Log "Found Ghost Key in HKCR\Products: $($_.PSPath)" "WARN"
            Remove-Item -Path $_.PSPath -Recurse -Force -ErrorAction SilentlyContinue
            $DeepCleanFound = $true
        }
    }
}

# B. Search & Destroy Stuck Rollback Scripts (Error 3:2)
if (Test-Path $HKLM_Rollback) {
    Write-Log "Found Zombie Rollback Key: $HKLM_Rollback" "WARN"
    Remove-Item -Path $HKLM_Rollback -Recurse -Force -ErrorAction SilentlyContinue
    $DeepCleanFound = $true
}

if ($DeepCleanFound) { Write-Log "Deep Clean performed actions. Registry should now be clear for fresh install." }
else { Write-Log "No hidden/corrupted keys found in Deep Clean sweep." }

# Optional: Cleanup Program Files
$ProgFiles = "$env:ProgramFiles\Liongard"
if (Test-Path $ProgFiles) { Remove-Item $ProgFiles -Recurse -Force -ErrorAction SilentlyContinue }
Start-Sleep -Seconds 5

# --- 11. Install Logic ---
Write-Log "Installing Fresh Liongard Agent..."
$EnvArg = if (-not [string]::IsNullOrWhiteSpace($Environment)) { "LIONGARDENVIRONMENT=`"$Environment`"" } else { "" }
$InstallLog = "$Folder\AgentInstall.log"
$InstallArgs = "/i `"$MsiPath`" LIONGARDURL=$Url LIONGARDACCESSKEY=$AccessKey LIONGARDACCESSSECRET=$AccessSecret $EnvArg LIONGARDAGENTNAME=`"$env:computername`" /qn /norestart /L*V `"$InstallLog`""

# Initialize generic failure code to prevent null reference in Catch block
$MsiExitCode = 1 

try {
    $Process = Start-Process -FilePath "msiexec.exe" -ArgumentList $InstallArgs -Wait -PassThru -NoNewWindow
    $MsiExitCode = $Process.ExitCode
    
    if ($MsiExitCode -ne 0 -and $MsiExitCode -ne 3010) { 
        $FailureReason = "Unknown MSI Error (Code $MsiExitCode)"
        Start-Sleep -Seconds 2 # Wait for log flush
        
        if (Test-Path $InstallLog) {
            $LogContent = Get-Content $InstallLog
            
            # --- INTELLIGENT ERROR PARSING ENGINE ---
            $SecurityBlock = $LogContent | Select-String -Pattern "Error code 0x80070005"
            $ServiceFail   = $LogContent | Select-String -Pattern "Error 1920"
            $PrivilegeErr  = $LogContent | Select-String -Pattern "Privileged rights are required"
            $Validation    = $LogContent | Select-String -Pattern "INVALIDMSG = (.*)" | Select-Object -Last 1
            $StandardErr   = $LogContent | Select-String -Pattern "Product: .* -- Error \d+" | Select-Object -Last 1
            
            # 1. SECURITY / THREATLOCKER (0x80070005)
            if ($SecurityBlock) { 
                Write-Log "***************************************************************" "ERROR"
                Write-Log "CRITICAL ERROR: SECURITY SOFTWARE BLOCK DETECTED" "ERROR"
                Write-Log "TYPE: Access Denied (0x80070005) on Temp Files" "ERROR"
                Write-Log "CAUSE: ThreatLocker, SentinelOne, or AppLocker is preventing the MSI from extracting files." "ERROR"
                Write-Log "ACTION: Whitelist 'Liongard Inc.' certificate or enable Installation Mode." "ERROR"
                Write-Log "***************************************************************" "ERROR"
                $FailureReason = "Security Software Blocked Installation."
            }
            # 2. SERVICE START FAILURE (1920)
            elseif ($ServiceFail) {
                Write-Log "***************************************************************" "ERROR"
                Write-Log "CRITICAL ERROR: SERVICE FAILED TO START (Error 1920)" "ERROR"
                Write-Log "CAUSE: The Agent installed, but the Service refused to start." "ERROR"
                Write-Log "LIKELY CULPRITS: 1) AV quarantined the EXE. 2) Missing .NET Framework." "ERROR"
                Write-Log "ACTION: Check AV logs for 'LiongardAgent.exe'." "ERROR"
                Write-Log "***************************************************************" "ERROR"
                $FailureReason = "Service failed to start during install (1920)."
            }
            # 3. VERSION CONFLICT (1638)
            elseif ($MsiExitCode -eq 1638) {
                Write-Log "***************************************************************" "ERROR"
                Write-Log "CRITICAL ERROR: NEWER VERSION DETECTED (Error 1638)" "ERROR"
                Write-Log "CAUSE: A newer (or same) version of the Agent is already installed." "ERROR"
                Write-Log "ACTION: Uninstall the existing agent manually before running this." "ERROR"
                Write-Log "***************************************************************" "ERROR"
                $FailureReason = "Newer version already installed (1638)."
            }
            # 4. INSTALLER BUSY (1618)
            elseif ($MsiExitCode -eq 1618) {
                Write-Log "***************************************************************" "ERROR"
                Write-Log "CRITICAL ERROR: WINDOWS INSTALLER IS BUSY (Error 1618)" "ERROR"
                Write-Log "CAUSE: Another installation (Windows Update/RMM) is running." "ERROR"
                Write-Log "ACTION: Wait 15 minutes and try again." "ERROR"
                Write-Log "***************************************************************" "ERROR"
                $FailureReason = "Windows Installer service is busy (1618)."
            }
            # 5. REGISTRY CORRUPTION (1612)
            elseif ($MsiExitCode -eq 1612) {
                Write-Log "***************************************************************" "ERROR"
                Write-Log "CRITICAL ERROR: REGISTRY CORRUPTION (Error 1612)" "ERROR"
                Write-Log "ACTION: Run the 'Liongard Deep Clean' script to purge HKCR\Installer\Products." "ERROR"
                Write-Log "***************************************************************" "ERROR"
                $FailureReason = "Registry Corruption (1612) - Deep Clean required."
            }
            # 6. USER CANCELLED (1602)
            elseif ($MsiExitCode -eq 1602) {
                $FailureReason = "Installation cancelled by user."
            }
            # 7. INPUT ERROR
            elseif ($Validation) { 
                $FailureReason = "INPUT ERROR: $($Validation.Matches.Groups[1].Value)" 
            }
            # 8. GENERIC SYSTEM ERROR
            elseif ($StandardErr) { 
                $FailureReason = "SYSTEM ERROR: $($StandardErr.Line)" 
            }
        }
        throw $FailureReason
    }
}
catch { Write-Log "$_" "ERROR"; Exit-Smart $MsiExitCode }

# --- 12. Verification ---
Write-Log "Verifying Service Startup (Max 120s)..."
$Retry = 0; $Started = $false; $DetectedServiceName = $null
do {
    Start-Sleep -Seconds 5
    $Service = Get-Service | Where-Object { $_.Name -like "*Liongard*" -or $_.DisplayName -like "*Liongard*" } | Select-Object -First 1
    if ($Service -and $Service.Status -eq "Running") { $DetectedServiceName = $Service.Name; $Started = $true }
    $Retry++
} until ($Started -or $Retry -ge 24)

if ($Started) { 
    Write-Log "SUCCESS: Service '$DetectedServiceName' is Running." 
    Remove-Item $MsiPath -Force -ErrorAction SilentlyContinue
    Exit-Smart 0
} else { 
    Write-Log "WARNING: Service installed but not running." "WARN"
    Exit-Smart 1
}
