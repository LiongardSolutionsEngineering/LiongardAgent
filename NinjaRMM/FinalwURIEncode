<#
.SYNOPSIS
    Liongard Agent Installation - Production Ready (v2.3.3)

.DESCRIPTION
    - Enforced Inputs: Friendly loop for humans, graceful exit for RMMs.
    - Race Condition Fix: Waits for MSI logs to flush.
    - Deep Error Analysis: Explains failures (401, Invalid URL, etc).
    - NinjaOne Script Variables Support: Reads values ONLY from Ninja "Script Variables" (environment variables).
      Expected Script Variable names:
        liongardurl
        liongardaccesskey
        liongardaccesssecret
        liongardenvironment (optional)
    - Environment Special Characters: Supports URL-encoded environment names in liongardenvironment.
      Example: "Will%20%26%20Bill" -> "Will & Bill"
    - Debug: Logs which required inputs are missing and what was detected (no secrets printed).
#>

param(
    [string]$Url,
    [string]$AccessKey,
    [string]$AccessSecret,
    [string]$Environment
)

# Track what was provided as a script argument (before Script Variable fallback)
$UrlFromArg          = -not [string]::IsNullOrWhiteSpace($Url)
$AccessKeyFromArg    = -not [string]::IsNullOrWhiteSpace($AccessKey)
$AccessSecretFromArg = -not [string]::IsNullOrWhiteSpace($AccessSecret)
$EnvironmentFromArg  = -not [string]::IsNullOrWhiteSpace($Environment)

# --- NinjaOne Script Variables Fallback (ONLY) ---
# NinjaOne "Script Variables" are typically injected as environment variables.
function Get-EnvVarSafe {
    param([Parameter(Mandatory=$true)][string]$Name)

    $v = [Environment]::GetEnvironmentVariable($Name)
    if ([string]::IsNullOrWhiteSpace($v)) { return $null }

    $t = $v.Trim()
    if ($t.ToLower() -eq "null") { return $null }

    return $t
}

$UrlFromScriptVar          = $false
$AccessKeyFromScriptVar    = $false
$AccessSecretFromScriptVar = $false
$EnvironmentFromScriptVar  = $false

if ([string]::IsNullOrWhiteSpace($Url)) {
    $v = Get-EnvVarSafe "liongardurl"
    if (-not [string]::IsNullOrWhiteSpace($v)) { $Url = $v; $UrlFromScriptVar = $true }
}
if ([string]::IsNullOrWhiteSpace($AccessKey)) {
    $v = Get-EnvVarSafe "liongardaccesskey"
    if (-not [string]::IsNullOrWhiteSpace($v)) { $AccessKey = $v; $AccessKeyFromScriptVar = $true }
}
if ([string]::IsNullOrWhiteSpace($AccessSecret)) {
    $v = Get-EnvVarSafe "liongardaccesssecret"
    if (-not [string]::IsNullOrWhiteSpace($v)) { $AccessSecret = $v; $AccessSecretFromScriptVar = $true }
}
if ([string]::IsNullOrWhiteSpace($Environment)) {
    $v = Get-EnvVarSafe "liongardenvironment"
    if (-not [string]::IsNullOrWhiteSpace($v)) { $Environment = $v; $EnvironmentFromScriptVar = $true }
}

# --- Decode Environment if it was URL-encoded ---
# Example: "Kantor%20%26%20Kantor" -> "Kantor & Kantor"
$EnvironmentWasUrlDecoded = $false
if (-not [string]::IsNullOrWhiteSpace($Environment)) {
    $envBefore = $Environment
    try {
        $decoded = [System.Uri]::UnescapeDataString($Environment)
        if (-not [string]::IsNullOrWhiteSpace($decoded) -and $decoded -ne $Environment) {
            $Environment = $decoded
            $EnvironmentWasUrlDecoded = $true
        }
    } catch {
        # If decoding fails, keep original
    }
}

# --- 0. Setup & Logging ---
$Folder          = "$env:ProgramData\Liongard"
$LogFile         = "$Folder\ScriptInstall.log"
$TranscriptPath  = "$Folder\TranscriptLog.txt"

if (-not (Test-Path -Path $Folder)) { New-Item -Path $Folder -ItemType Directory -ErrorAction SilentlyContinue | Out-Null }

try { Start-Transcript -Path $TranscriptPath -Append -Force -ErrorAction Stop }
catch { Write-Host "WARNING: Transcript failed. Proceeding without it." -ForegroundColor Yellow }

function Write-Log {
    param( [string]$Message, [string]$Type="INFO" )
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogEntry = "[$Timestamp] [$Type] $Message"
    Write-Host $LogEntry
    Add-Content -Path $LogFile -Value $LogEntry -Encoding Default -ErrorAction SilentlyContinue
}

function Exit-Smart {
    param ([int]$Code)
    Stop-Transcript -ErrorAction SilentlyContinue

    if ([Environment]::UserInteractive) {
        Write-Host "`n---------------------------------------------------"
        if ($Code -ne 0) { Write-Host "SCRIPT FAILED (Exit Code $Code) - Check logs above." -ForegroundColor Red }
        else { Write-Host "SCRIPT FINISHED SUCCESSFULLY" -ForegroundColor Green }
        Write-Host "---------------------------------------------------"
        Read-Host "Press Enter to close this window..."
    }
    Exit $Code
}

function Mask-Secret {
    param([string]$Value)
    if ([string]::IsNullOrWhiteSpace($Value)) { return "<missing>" }
    $v = $Value.Trim()
    $len = $v.Length
    if ($len -le 4) { return "<present len=$len>" }
    $head = $v.Substring(0,2)
    $tail = $v.Substring($len-2,2)
    return "<present len=$len preview=$head****$tail>"
}

function Get-SourceLabel {
    param([bool]$FromArg, [bool]$FromScriptVar, [string]$FinalValue)
    if ($FromArg) { return "ScriptArg" }
    if ($FromScriptVar) { return "ScriptVar" }
    if (-not [string]::IsNullOrWhiteSpace($FinalValue)) { return "Other" }
    return "Missing"
}

Write-Log "--- Starting Liongard Agent Installation (v2.3.3) ---"
Write-Log ("Script Variable sources: Url={0}, AccessKey={1}, AccessSecret={2}, Environment={3}" -f `
    (Get-SourceLabel $UrlFromArg $UrlFromScriptVar $Url), `
    (Get-SourceLabel $AccessKeyFromArg $AccessKeyFromScriptVar $AccessKey), `
    (Get-SourceLabel $AccessSecretFromArg $AccessSecretFromScriptVar $AccessSecret), `
    (Get-SourceLabel $EnvironmentFromArg $EnvironmentFromScriptVar $Environment)
) "DEBUG"

Write-Log ("Detected Url: {0}" -f ($(if ($Url) { $Url } else { "<missing>" }))) "DEBUG"
Write-Log ("Detected AccessKey: {0}" -f (Mask-Secret $AccessKey)) "DEBUG"
Write-Log ("Detected AccessSecret: {0}" -f (Mask-Secret $AccessSecret)) "DEBUG"
Write-Log ("Detected Environment: {0}" -f ($(if ($Environment) { $Environment } else { "<blank>" }))) "DEBUG"

if ($EnvironmentWasUrlDecoded) {
    Write-Log "Environment value was URL-decoded successfully." "DEBUG"
}

# --- 1. The "Friendly Enforcer" Input Function ---
function Get-RequiredInput {
    param ( [string]$CurrentValue, [string]$PromptName )

    # 1. If passed via RMM/Param, use it.
    if (-not [string]::IsNullOrWhiteSpace($CurrentValue)) { return $CurrentValue }

    # 2. If RMM (Headless), we can't ask. Return null to trigger graceful failure.
    if (-not [Environment]::UserInteractive) { return $null }

    # 3. Interactive Loop (Friendly Reminder)
    $Val = $null
    do {
        $Val = Read-Host "`n$PromptName (Required)"
        if ([string]::IsNullOrWhiteSpace($Val)) {
            Write-Host "   [!] We can't proceed without the $PromptName." -ForegroundColor Yellow
            Write-Host "       Please enter it to continue." -ForegroundColor Gray
        }
    } until (-not [string]::IsNullOrWhiteSpace($Val))

    return $Val
}

# --- 2. Get Inputs (with Enforcement) ---
$Url          = Get-RequiredInput -CurrentValue $Url          -PromptName "1. Liongard URL"
$AccessKey    = Get-RequiredInput -CurrentValue $AccessKey    -PromptName "2. Access Key ID"
$AccessSecret = Get-RequiredInput -CurrentValue $AccessSecret -PromptName "3. Access Key Secret"

# Environment is optional, so we use standard Read-Host logic (no enforcement loop)
if ([string]::IsNullOrWhiteSpace($Environment) -and [Environment]::UserInteractive) {
    $Environment = Read-Host "`n4. Environment Name (Optional - Press Enter to skip)"
}

# --- 3. RMM Graceful Handling (Validation) ---
$Missing = @()
if (-not $Url)          { $Missing += "Url" }
if (-not $AccessKey)    { $Missing += "AccessKey" }
if (-not $AccessSecret) { $Missing += "AccessSecret" }

if ($Missing.Count -gt 0) {
    Write-Log ("FATAL ERROR: Missing required variables: {0}" -f ($Missing -join ", ")) "ERROR"
    Write-Log ("Final detected state: Url={0}, AccessKey={1}, AccessSecret={2}, Environment={3}" -f `
        ($(if ($Url) { $Url } else { "<missing>" })), (Mask-Secret $AccessKey), (Mask-Secret $AccessSecret), ($(if ($Environment) { $Environment } else { "<blank>" }))) "ERROR"
    Write-Log "If running via RMM, you MUST populate NinjaOne Script Variables or pass script arguments." "ERROR"
    Exit-Smart 1
}

# --- 4. Sanitization ---
if ($Url -match "https://") { $Url = $Url -replace "https://","" -replace "/","" }
if ($Url -notmatch "\.app\.liongard\.com") {
    $Url = "$Url.app.liongard.com"
    Write-Log "Auto-corrected URL to: $Url"
}

$MsiPath         = "$env:TEMP\LiongardAgent-lts.msi"
$DownloadUri     = "https://agents.static.liongard.com/LiongardAgent-lts.msi"
$MinMsiSize      = 10485760
$MinFreeSpaceMB  = 200
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12

# --- 5. Pre-Flight Checks ---
Write-Log "Checking for existing Liongard Agent Service..."
if (Get-Service | Where-Object { $_.Name -like "*Liongard*" -or $_.DisplayName -like "*Liongard*" }) {
    Write-Log "A Liongard Agent service is already present. Aborting." "WARN"
    Exit-Smart 0
}

try {
    $Disk = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'" | Select-Object FreeSpace
    if (([math]::Round($Disk.FreeSpace / 1MB)) -lt $MinFreeSpaceMB) { throw "Insufficient disk space." }

    Write-Log "Verifying connectivity..."
    $Request = [System.Net.WebRequest]::Create($DownloadUri); $Request.Method = "HEAD"; $Response = $Request.GetResponse(); $Response.Close()
}
catch { Write-Log "Pre-check failed: $_" "ERROR"; Exit-Smart 1 }

# --- 6. Download & Install ---
Write-Log "Downloading MSI..."
try {
    Invoke-WebRequest -Uri $DownloadUri -OutFile $MsiPath -UseBasicParsing -ErrorAction Stop
    if ((Get-Item $MsiPath).Length -lt $MinMsiSize) { throw "File too small." }
}
catch { Write-Log "Download failed: $_" "ERROR"; Exit-Smart 1 }

Write-Log "Installing Liongard Agent..."
$EnvArg = if (-not [string]::IsNullOrWhiteSpace($Environment)) { "LIONGARDENVIRONMENT=`"$Environment`"" } else { "" }
$InstallLog = "$Folder\AgentInstall.log"
$InstallArgs = "/i `"$MsiPath`" LIONGARDURL=$Url LIONGARDACCESSKEY=$AccessKey LIONGARDACCESSSECRET=$AccessSecret $EnvArg LIONGARDAGENTNAME=`"$env:computername`" /qn /norestart /L*V `"$InstallLog`""

try {
    $Process = Start-Process -FilePath "msiexec.exe" -ArgumentList $InstallArgs -Wait -PassThru -NoNewWindow

    if ($Process.ExitCode -ne 0 -and $Process.ExitCode -ne 3010) {
        $FailureReason = "Unknown MSI Error (Code $($Process.ExitCode))"
        Start-Sleep -Seconds 2 # Wait for log flush

        if (Test-Path $InstallLog) {
            $LogContent = Get-Content $InstallLog
            $Validation = $LogContent | Select-String -Pattern "INVALIDMSG = (.*)" | Select-Object -Last 1
            $StandardErr = $LogContent | Select-String -Pattern "Product: .* -- Error \d+" | Select-Object -Last 1
            $InternalErr = $LogContent | Select-String -Pattern "Note: 1: \d+ 2: (.*)" | Select-Object -Last 1

            if ($Validation) { $FailureReason = "INPUT ERROR: $($Validation.Matches.Groups[1].Value)" }
            elseif ($StandardErr) { $FailureReason = "SYSTEM ERROR: $($StandardErr.Line)" }
            elseif ($InternalErr) { $FailureReason = "INSTALLER ERROR: $($InternalErr.Matches.Groups[1].Value)" }
        }

        throw $FailureReason
    }
}
catch { Write-Log "$_" "ERROR"; Exit-Smart 1 }

# --- 7. Verification ---
Write-Log "Verifying Service Startup (Max 120s)..."
$Retry = 0; $Started = $false; $DetectedServiceName = $null
do {
    Start-Sleep -Seconds 5
    $Service = Get-Service | Where-Object { $_.Name -like "*Liongard*" -or $_.DisplayName -like "*Liongard*" } | Select-Object -First 1
    if ($Service -and $Service.Status -eq "Running") { $DetectedServiceName = $Service.Name; $Started = $true }
    $Retry++
} until ($Started -or $Retry -ge 24)

if ($Started) {
    Write-Log "SUCCESS: Service '$DetectedServiceName' is Running."
    Remove-Item $MsiPath -Force -ErrorAction SilentlyContinue
    Exit-Smart 0
} else {
    Write-Log "WARNING: Service installed but not running." "WARN"
    Exit-Smart 1
}
